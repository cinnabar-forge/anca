import { AncaDevelopment, AncaReadmeUsageSection } from "../schema.js";
import { formatAuthorLine, writeFolderFile } from "../utils.js";

const FILE_PATH = "README.md";

/**
 *
 * @param development
 */
function getContents(development: AncaDevelopment) {
  if (development.state == null) {
    return "";
  }

  const appName = development.state.config.namings?.text ?? "New App";
  const packageName =
    development.state.config.namings?.npmPackage ?? "@anca/new-app";

  const lines = [];

  lines.push(`# ${appName}`);

  if (development.state.meta?.version?.isUnstable) {
    lines.push(
      `> **DISCLAIMER**: This project is not production ready. All versions below 1.0.0 should be considered unstable`,
    );
  }

  if (development.state.meta?.description) {
    lines.push(`${development.state.meta.description}`);
  }

  if (development.state.config.development?.readme?.description) {
    lines.push(...development.state.config.development.readme.description);
  }

  if (development.state.config.development?.readme?.features) {
    lines.push(`## Features`);
    development.state.config.development.readme.features.forEach((feature) => {
      lines.push(`- ${feature}`);
    });
  }

  lines.push(`## Installation`);

  if (
    development.state.config.stack === "nodejs" &&
    development.state.jsonFiles["package.json"] != null
  ) {
    const binName = development.state.meta?.name;

    if (
      development.state.config.type === "app" &&
      development.state.config.downloadBinariesUrl
    ) {
      lines.push(`### Binary`);
      lines.push(
        `[Get the latest binaries](${development.state.config.downloadBinariesUrl}).`,
      );
      lines.push(
        `If you want to use the app with a command line, rename it to \`${binName}\` or \`${binName}.exe\` and add the location to \`PATH\`.`,
      );
    }

    lines.push(`### npm`);
    if (development.state.config.type === "app") {
      lines.push(`\`\`\`bash\nnpm install -g ${packageName}\n\`\`\``);
    } else {
      lines.push(`\`\`\`bash\nnpm install ${packageName}\n\`\`\``);
    }
  }

  if (development.state.config.development?.readme?.usage) {
    lines.push(`## Usage`);

    const generateUsageSection = (
      sections: AncaReadmeUsageSection[],
      level: number,
    ) => {
      sections.forEach((section) => {
        if (section.name != null) {
          lines.push(`${"#".repeat(level)} ${section.name}`);
        }
        if (section.description) {
          lines.push(`${section.description}`);
        }
        if (section.language && section.code) {
          lines.push(
            `\`\`\`${section.language}\n${section.code.join("\n")}\n\`\`\``,
          );
        }
        if (section.sections) {
          generateUsageSection(section.sections, level + 1);
        }
      });
    };

    generateUsageSection(development.state.config.development.readme.usage, 3);
  }

  lines.push(`## Contributing`);
  lines.push(`Visit [\`CONTRIBUTING.md\`](CONTRIBUTING.md).`);

  if (development.state.config.authors) {
    const maintainers = development.state.config.authors.filter(
      (author) =>
        (author.type === "author" || author.type === "maintainer") &&
        author.status !== "retired",
    );
    if (maintainers.length > 1) {
      lines.push(`Current maintainers:`);
      lines.push(...maintainers.map(formatAuthorLine));
    } else if (maintainers.length === 1) {
      lines.push(`Current maintainer ${formatAuthorLine(maintainers[0])}`);
    }
  }

  lines.push(`## License`);
  lines.push(`Visit [\`LICENSE\`](LICENSE).`);

  lines.push(`## Anca`);
  lines.push(
    `This repository is a part of [Anca](https://github.com/cinnabar-forge/anca) standardization project. Parts of the files and code are generated by Anca.`,
  );

  return lines.join("\n\n") + "\n";
}

/**
 *
 * @param development
 */
export async function checkReadmeMd(development: AncaDevelopment) {
  if (development.state == null) {
    return;
  }
  const contents = development.state.files[FILE_PATH];
  if (contents == null) {
    console.log("No README.md file found");
    return false;
  }

  return contents === getContents(development);
}

/**
 *
 * @param development
 */
export async function fixReadmeMd(development: AncaDevelopment) {
  if (development.state == null) {
    return;
  }
  await writeFolderFile(
    development.fullPath,
    FILE_PATH,
    getContents(development),
  );
}
